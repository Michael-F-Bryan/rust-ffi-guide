# Generating Bindings and Writing Wrappers

A lot of the time you'll have a large amount of existing C (or C++, but more of 
that later) code which you need to integrate your Rust tools into, a great 
example of this is [OpenSSl][openssl] or [git][git]. Unless the C code is 
fairly small or trivial it's not going to be feasible to port to Rust, plus
why re-invent the wheel?

Luckily with Rust you can have your cake and eat it too. As you'll already know
Rust can transparently call C functions as long as you have declarations for
them (so the compiler knows what symbols to use). Enter [bindgen][bindgen].

Bindgen does all the hard work of parsing C-style header files and generating 
the equivalent Rust function definitions. They've also got a 
[great tutorial][tut] for getting started. This section focuses mostly on the
high level stuff required when using a C library from Rust, seeing as the zero
cost abstractions and high level way of thinking is probably why you're trying
to use Rust in a C/C++ codebase in the first place!


## Getting Set Up

> **Note:** Bindgen **requires** clang. Installation instructions can be found [here](https://github.com/rust-lang-nursery/rust-bindgen/blob/master/book/src/requirements.md#installing-clang-39)

> **Note:** `bzip2` **and** its headers must be installed on your system.
> This has been tested on Linux, the process for getting `bzip2` working
> on Windows will differ. (If you can help, please file an [issue]).

Continuing on from where the [great bindgen tutorial][tut] left off, we'll
write an idiomatic Rust wrapper around `bzip2`. This assumes you've already read
through that tutorial and will focus more on the next step, writing the actual
wrapper code using common Rust patterns.

First, we'll create a new crate:

```bash
$ cargo new bzip2
```

Then add `bindgen` as a dependency and tell `Cargo` about our build script
(which doesn't actually exist yet):

```
 name = "bzip2"
 version = "0.1.0"
 authors = ["Michael-F-Bryan <michaelfbryan@gmail.com>"]
+build = "build.rs"
 
 [dependencies]
+
+[build-dependencies]
+bindgen = "0.20.0"
```

`Bindgen` works by reading a `C`-style header file using `libclang`, then
it runs the preprocessor and creates bindings based on the output. Therefore, 
the build script needs a dummy header which pulls in the `bzip2` library
installed on your system.

```c
// wrapper.h
#include <bzlib.h>
```

Creating the `build.rs` script allows for bindings to be generated for the
crate before it's compiled. The contents of
[build.rs](./bindgen/bzip2/build.rs) are below.

```Rust
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rustc-link-lib=bz2");

    let bindings = bindgen::Builder::default()
        .no_unstable_rust()
        .header("wrapper.h")
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```

Let's test that everything created so far actually compiles.

```bash
$ cargo build 
    Updating registry `https://github.com/rust-lang/crates.io-index`
Downloading bindgen v0.20.5
Downloading syntex_syntax v0.54.0
...
Finished debug [unoptimized + debuginfo] target(s) in 12.41 secs
```

No code has been written yet, so the `lib.rs` file should still
just have the auto-generated `it_works()` test. If you want to view the
generated bindings, you'll see that it's not exactly the nicest Rust code to
look at...

```bash
$ find -name "bindings.rs"
./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs
```

And a couple excerpts from that file:

```Rust
// selected output from ./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}

...

pub const BZ_RUN: ::std::os::raw::c_uint = 0;
pub const BZ_FLUSH: ::std::os::raw::c_uint = 1;
pub const BZ_FINISH: ::std::os::raw::c_uint = 2;
pub const BZ_OK: ::std::os::raw::c_uint = 0;
pub const BZ_RUN_OK: ::std::os::raw::c_uint = 1;
pub const BZ_FLUSH_OK: ::std::os::raw::c_uint = 2;

...

#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub next_in: *mut ::std::os::raw::c_char,
    pub avail_in: ::std::os::raw::c_uint,
    pub total_in_lo32: ::std::os::raw::c_uint,
    pub total_in_hi32: ::std::os::raw::c_uint,
    pub next_out: *mut ::std::os::raw::c_char,
    pub avail_out: ::std::os::raw::c_uint,
    pub total_out_lo32: ::std::os::raw::c_uint,
    ...
}
pub type bz_stream = _bindgen_ty_1;
```

A common pattern is to put all FFI bindings in their own sub-module, therefore
we'll replace the contents of `lib.rs` and recompile.

```Rust
// lib.rs
#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub mod ffi {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
```

> **Note:** You'll notice the `ffi` module is public. This can be done just during
> the development stage to take advantage of docs `rustdoc` generates via
> `cargo doc --open`. It can be made private later on so users are forced to go
> through the proper Rust API.


## Creating The Rust Wrapper

Now, with a basic crate and build system working (i.e. `bindgen` creating the
crate's bindings), work can start on wrapping the `bzip2` library and giving it
a safe API.

The best way to figure out how our wrapper API should look is to find existing
code and (roughly) copy that. Luckily `libbzip2` documents its low level
interface [on their website][libbzip2] and they explain how each of the
functions work. Here's a snippet from their docs explaining how to compress some
data:

> That still looks complicated? Well, fair enough. The usual sequence of 
> calls for compressing a load of data is:
>
> 1. Get started with `BZ2_bzCompressInit()`.
> 
> Shovel data in and shlurp out its compressed form using zero or more calls 
> of `BZ2_bzCompress()` with action = `BZ_RUN`.
>
> Finish up. Repeatedly call `BZ2_bzCompress()` with action = `BZ_FINISH`, 
> copying out the compressed output, until `BZ_STREAM_END` is returned.
>
> Close up and go home. Call `BZ2_bzCompressEnd()`.

From this, one way of doing things is to have some `Compressor` object which
contains the `bz_stream`. It'll run `BZ2_bzCompressInit()` in the constructor
and have a `Drop` impl which calls `BZ2_bzCompressEnd()`. To make things
simple this won't be a streaming compressor so it'll just compress everything
from an input `Read`-er and write it to a `Write`-r. This isn't recommended
for compressing gigabyte-sized files, but it should work well enough.

Error handling should be fairly easy, all `libbzip2` functions return an
integer which corresponds to a error code, this can be mapped to a Rust enum 
with a `std::convert::From<i32>` impl for convenience (so you can call 
`error_code.into()` to automatically get the error enum).

Technically the `BZ2_bzCompressEnd()` destructor could fail if it is passed an
invalid stream, but there isn't much you can do in that situation, so any 
errors in destroying the stream will be ignored.

First for the `Compressor` definition:

```Rust
pub struct Compressor {
    stream: Box<ffi::bz_stream>,
}
```

Next, we'll write a `new()` method which creates a zeroed `bz_stream` and then
initializes it with the `BZ2_bzCompressInit()` function. You'll notice that
any return code other than `ffi::BZ_OK` is cast to i32 and converted to a 
`Bzip2Error`.

```Rust
impl Compressor {
    pub fn new() -> Result<Compressor, Bzip2Error> {
        unsafe {
            let mut comp = Compressor { stream: Box::new(mem::zeroed()) };
            let result = ffi::BZ2_bzCompressInit(&mut *comp.stream,
                                                 1, // 1 x 100000 block size
                                                 0, // verbosity (4 = most verbose)
                                                 0); // default work factor
            match result as u32 {
                ffi::BZ_OK => Ok(comp),
                other => Err((other as i32).into()),
            }
        }
    }
```

The `compress()` method is a bit more complicated, it must:

* Read all the input into a buffer
* Create an output buffer of similar length
* Set the corresponding properties on the `self.stream` struct so that
    `libbzip2` knows where the buffers are and their sizes
* Call the `ffi::BZ2_bzCompress()` function
* Deal with the result by either:
    * Writing the compressed output to the destination, or
    * Returning the correct error

```Rust
    pub fn compress<R: Read, W: Write>(&mut self,
                                       mut src: R,
                                       mut dest: W)
                                       -> Result<(), Bzip2Error> {
        let mut input = vec![];
        src.read_to_end(&mut input)?;
        let mut compressed_output = vec![0; input.len()];

        self.stream.next_in = input.as_ptr() as *mut _;
        self.stream.avail_in = input.len() as _;
        self.stream.next_out = compressed_output.as_mut_ptr() as *mut _;
        self.stream.avail_out = compressed_output.len() as _;

        unsafe {
            let result = ffi::BZ2_bzCompress(&mut *self.stream, ffi::BZ_FINISH as _);
            match result as u32 {
                ffi::BZ_FINISH_OK |
                ffi::BZ_RUN_OK |
                ffi::BZ_FLUSH_OK |
                ffi::BZ_STREAM_END => {
                    dest.write_all(&mut compressed_output)
                        .map(|_| ())
                        .map_err(|e| e.into())
                }
                other => Err((other as i32).into()),
            }
        }
    }
}
```

> **Note:** This function definitely violates the *Single Responsibility
> Principle* and should be refactored out into several functions, but for the
> sake of this example it's not a concern.

Finally, to make sure everything is cleaned up correctly afterwards, a `Drop`
implementation is needed. This one is really simple.

```Rust
impl Drop for Compressor {
    fn drop(&mut self) {
        unsafe {
            ffi::BZ2_bzCompressEnd(&mut *self.stream);
        }
    }
}
```

> **Exercise for the reader:** Try to figure out a way to handle errors in the
> destructor. What would happen when there's a panic further down the stack and 
> this `drop()` fails when it's unrolling?

To handle errors, we'll make an enum which corresponds to either a `libbzip2`
error constant or an `io::Error`. 

```Rust
#[derive(Debug)]
pub enum Bzip2Error {
    Config,
    Params,
    Memory,
    InvalidSequence,
    Io(Box<io::Error>),
}

impl From<i32> for Bzip2Error {
    fn from(val: i32) -> Bzip2Error {
        match val {
            ffi::BZ_CONFIG_ERROR => Bzip2Error::Config,
            ffi::BZ_PARAM_ERROR => Bzip2Error::Params,
            ffi::BZ_MEM_ERROR => Bzip2Error::Memory,
            ffi::BZ_SEQUENCE_ERROR => Bzip2Error::InvalidSequence,
            unknown => panic!("Invalid error code: {}", unknown),
        }
    }
}

impl From<io::Error> for Bzip2Error {
    fn from(val: io::Error) -> Bzip2Error {
        Bzip2Error::Io(Box::new(val))
    }
}
```

(The full [lib.rs](./bindgen/bzip2/src/lib.rs))


[openssl]: https://github.com/sfackler/rust-openssl
[git]: https://github.com/alexcrichton/git2-rs
[bindgen]: https://github.com/servo/rust-bindgen
[tut]: http://fitzgeraldnick.com/2016/12/14/using-libbindgen-in-build-rs.html
[libtcod]: https://bitbucket.org/libtcod/libtcod
[git-hg]: https://github.com/cosmin/git-hg
[ubuntu-instructions]: https://bitbucket.org/libtcod/libtcod/src/f3486b0851a2acf11efbd2df18fc06501012afef/README-linux-SDL2.md?fileviewer=file-view-default
[libbzip2]: http://www.bzip.org/1.0.5/bzip2-manual-1.0.5.html#libprog
[issue]: https://github.com/Michael-F-Bryan/rust-ffi-guide/issues/new
