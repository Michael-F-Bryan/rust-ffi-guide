<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Generating a Header File - The (unofficial) Rust FFI Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Using unsafe for fun and profit!">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./overview.html"><strong>1.</strong> Overview</a></li><li><a href="./setting_up.html"><strong>2.</strong> Setting Up</a></li><li><a href="./client.html"><strong>3.</strong> Core Client Library</a></li><li><a href="./basic_request.html"><strong>4.</strong> Constructing a Basic Request</a></li><li><a href="./send_basic.html"><strong>5.</strong> Sending the Request</a></li><li><a href="./cbindgen.html" class="active"><strong>6.</strong> Generating a Header File</a></li><li><a href="./errors/index.html"><strong>7.</strong> Better Error Handling</a></li><li><ul class="section"><li><a href="./errors/return_types.html"><strong>7.1.</strong> Return Types</a></li><li><a href="./errors/logging.html"><strong>7.2.</strong> Logging</a></li><li><a href="./errors/exception_safety.html"><strong>7.3.</strong> Exception Safety</a></li></ul></li><li><a href="./async.html"><strong>8.</strong> Asynchronous Operations</a></li><li><a href="./complex_request.html"><strong>9.</strong> More Complex Requests</a></li><li><a href="./testing.html"><strong>10.</strong> Testing</a></li><li><a href="./dynamic_loading.html"><strong>11.</strong> Dynamic Loading &amp; Plugins</a></li><li class="spacer"></li><li><a href="./fun/index.html"><strong>12.</strong> Break All The Things!!1!</a></li><li><ul class="section"><li><a href="./fun/problems.html"><strong>12.1.</strong> Problems</a></li><li><a href="./fun/solutions.html"><strong>12.2.</strong> Solutions</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The (unofficial) Rust FFI Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./cbindgen.html#generating-a-header-file" id="generating-a-header-file"><h1>Generating a Header File</h1></a>
<p>Instead of having to constantly keep <code>ffi.rs</code> and the various <code>extern</code> blocks
scattered through out our C++ code in sync, it'd be really nice if we could
generate a header file that corresponds to <code>ffi.rs</code> and just <code>#include</code> that.
Fortunately there exists a tool which does exactly this called <a href="https://github.com/eqrion/cbindgen">cbindgen</a>!</p>
<a class="header" href="./cbindgen.html#adding-cbindgen" id="adding-cbindgen"><h2>Adding Cbindgen</h2></a>
<p>You can use <code>cbindgen</code> to generate header files in a couple ways, the first is
to use <code>cargo install</code> and run the binding generator program.</p>
<pre><code>$ cargo install cbindgen
$ cd /path/to/my/project &amp;&amp; cbindgen . -o target/my_project.h
</code></pre>
<p>However running this after every change can get quite repetitive, therefore the
<em>README</em> includes a minimal build script which will automatically generate the
header every time you compile.</p>
<p>First add <code>cbindgen</code> as a build dependency (<a href="https://crates.io/crates/cargo-edit">cargo-edit</a> makes this quite easy).</p>
<pre><code>$ cargo add --build cbindgen
</code></pre>
<p>You also need to make sure you have a <code>build</code> script entry in your <code>Cargo.toml</code>.</p>
<pre><code class="language-diff">...
description = &quot;The business logic for a REST client&quot;
name = &quot;client&quot;
repository = &quot;https://github.com/Michael-F-Bryan/rust-ffi-guide&quot;
version = &quot;0.1.0&quot;
+ build = &quot;build.rs&quot;
+
+ [build-dependencies]
+ cbindgen = &quot;0.1.29&quot;

[dependencies]
chrono = &quot;0.4.0&quot;
...
</code></pre>
<p>Finally you can flesh out the build script itself. This is fairly
straightforward, although because we want to put the generated header file in
the <code>target/</code> directory we need to take special care to detect when <code>cmake</code>
overrides the default.</p>
<pre><pre class="playpen"><code class="language-rust">// client/build.rs

extern crate cbindgen;

use std::env;
use std::path::PathBuf;
use cbindgen::Config;


fn main() {
    let crate_dir = env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap();

    let package_name = env::var(&quot;CARGO_PKG_NAME&quot;).unwrap();
    let output_file = target_dir()
        .join(format!(&quot;{}.hpp&quot;, package_name))
        .display()
        .to_string();

    let config = Config {
        namespace: Some(String::from(&quot;ffi&quot;)),
        ..Default::default()
    };

    cbindgen::generate_with_config(&amp;crate_dir, config)
      .unwrap()
      .write_to_file(&amp;output_file);
}

/// Find the location of the `target/` directory. Note that this may be 
/// overridden by `cmake`, so we also need to check the `CARGO_TARGET_DIR` 
/// variable.
fn target_dir() -&gt; PathBuf {
    if let Ok(target) = env::var(&quot;CARGO_TARGET_DIR&quot;) {
        PathBuf::from(target)
    } else {
        PathBuf::from(env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap()).join(&quot;target&quot;)
    }
}
</code></pre></pre>
<p>Note that the <code>build.rs</code> build script also creates a custom <code>Config</code> that
specifies everything in the generated header file should be under the <code>ffi</code>
namespace. This means we won't get name clashes between the opaque <code>Request</code> and
<code>Response</code> types generated by <code>cbindgen</code> and our own wrapper classes.</p>
<p>If you go back to the <code>build/</code> directory and recompile, you should now see the
<code>client.hpp</code> header file.</p>
<pre><code>$ cd build/
$ cmake -DCMAKE_BUILD_TYPE=Debug ..
$ make
$ ls client
client.hpp  cmake_install.cmake  CMakeFiles  CTestTestfile.cmake  debug  libclient.so  Makefile

$ cat client/client.hpp
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;

extern &quot;C&quot; {

namespace ffi {

// A HTTP request.
struct Request;

struct Response;

// Initialize the global logger and log to `rest_client.log`.
//
// Note that this is an idempotent function, so you can call it as many
// times as you want and logging will only be initialized the first time.
void initialize_logging();

// Construct a new `Request` which will target the provided URL and fill out
// all other fields with their defaults.
//
// # Note
...
</code></pre>
<p>This header file is also <code>#include</code>-able from all your C++ code, meaning you no
longer need to write all those manual <code>extern &quot;C&quot;</code> declarations. It also lets
you rely on the compiler to do proper type checking instead of getting ugly
linker errors if your forward declarations become out of sync (or crashes and
data corruption if function arguments change).</p>
<p>To actually <code>#include</code> the generated header file we need to make a couple
adjustments to the <code>CMakeLists.txt</code> file to let <code>cmake</code> know to add the
<code>build/client/</code> output directory to the include path.</p>
<pre><code class="language-diff"># gui/CMakeLists.txt

set(CMAKE_INCLUDE_CURRENT_DIR ON)
find_package(Qt5Widgets)

+ set(CLIENT_BUILD_DIR ${CMAKE_BINARY_DIR}/client)
+ include_directories(${CLIENT_BUILD_DIR})
+
set(SOURCE main_window.cpp main_window.hpp wrappers.cpp wrappers.hpp main.cpp)

add_executable(gui ${SOURCE})
</code></pre>
<p>Now you just need to update the <code>wrappers.cpp</code> and <code>wrappers.hpp</code> files to
<code>#include</code> this new <code>client.hpp</code>, delete the <code>extern &quot;C&quot;</code> block, and update the
Rust function call sites to be prefixed with the <code>ffi::</code> namespace. As a bonus
we can also replace a bunch of <code>void *</code> pointers with proper strongly-typed
pointers.</p>
<p>This step may take a couple iterations to make sure all the types match up and
everything compiles again. Make sure to test it all works by running the <code>gui</code>
program and hitting our GUI's dummy button. If everything is okay then you
should see HTML for the Rust website printed to the console.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./send_basic.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./errors/index.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./send_basic.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./errors/index.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
