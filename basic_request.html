<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Constructing a Basic Request - The (unofficial) Rust FFI Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Using unsafe for fun and profit!">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./overview.html"><strong>1.</strong> Overview</a></li><li><a href="./setting_up.html"><strong>2.</strong> Setting Up</a></li><li><a href="./client.html"><strong>3.</strong> Core Client Library</a></li><li><a href="./basic_request.html" class="active"><strong>4.</strong> Constructing a Basic Request</a></li><li><a href="./send_basic.html"><strong>5.</strong> Sending the Request</a></li><li><a href="./cbindgen.html"><strong>6.</strong> Generating a Header File</a></li><li><a href="./errors/index.html"><strong>7.</strong> Better Error Handling</a></li><li><ul class="section"><li><a href="./errors/return_types.html"><strong>7.1.</strong> Return Types</a></li><li><a href="./errors/logging.html"><strong>7.2.</strong> Logging</a></li><li><a href="./errors/exception_safety.html"><strong>7.3.</strong> Exception Safety</a></li></ul></li><li><a href="./async.html"><strong>8.</strong> Asynchronous Operations</a></li><li><a href="./complex_request.html"><strong>9.</strong> More Complex Requests</a></li><li><a href="./testing.html"><strong>10.</strong> Testing</a></li><li><a href="./dynamic_loading.html"><strong>11.</strong> Dynamic Loading &amp; Plugins</a></li><li class="spacer"></li><li><a href="./fun/index.html"><strong>12.</strong> Break All The Things!!1!</a></li><li><ul class="section"><li><a href="./fun/problems.html"><strong>12.1.</strong> Problems</a></li><li><a href="./fun/solutions.html"><strong>12.2.</strong> Solutions</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The (unofficial) Rust FFI Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./basic_request.html#constructing-a-basic-request" id="constructing-a-basic-request"><h1>Constructing a Basic Request</h1></a>
<p>In this step we want to construct a very simple <code>Request</code> which we can later use
to tell the <code>client</code> module to fetch http://google.com/. This requires roughly
three steps:</p>
<ul>
<li>Create a C interface which exposes our Rust <code>Request</code> in a way that can be used
and manipulated from our C++ application,</li>
<li>Write a thin C++ wrapper class which gives us an abstraction over the raw
C-style interface, and</li>
<li>Update the form so it can accept user inputs and create our <code>Request</code>.</li>
</ul>
<p>We'll also touch on the following topics:</p>
<ul>
<li>Exposing a FFI interface in Rust</li>
<li>Calling Rust functions from C++</li>
<li>Passing strings back and forth across the FFI barrier</li>
<li>Passing an opaque Rust struct to C++ and ensuring it gets free'd at the
correct time</li>
</ul>
<a class="header" href="./basic_request.html#creating-the-c-interface" id="creating-the-c-interface"><h2>Creating the C Interface</h2></a>
<p>First we need to add a couple small <code>extern &quot;C&quot;</code> functions to the Rust <code>client</code>
module. The easiest way to do this is by creating a separate <code>ffi.rs</code> module
to isolate all <code>unsafe</code> code to one place.</p>
<p>The bare minimum we need to do at this point is create a constructor and
destructor for <code>Request</code>. The constructor can take in the target URL (as a
<code>char *</code> string) and then fill in all the other fields with their defaults.</p>
<p>Because our <code>Request</code> contains Rust-specific things like generics we need to
hide it behind a raw pointer. This is actually pretty easy to do; you move the
<code>Request</code> to the heap with <code>Box::new()</code>, then call <code>Box::into_raw()</code> to get a
raw pointer to the <code>Request</code>. The dangerous part here is that the compiler will
no longer make sure the <code>Request</code> is destroyed once it goes out of scope, so
we need to <code>drop</code> it manually.</p>
<p>By far the most annoying bit in the constructor will be converting a raw C
string into a valid <code>Url</code>. This requires a couple transformations along the way,
all of which may fail, and we need to make sure this is dealt with correctly so
the program doesn't blow up at runtime.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

//! The foreign function interface which exposes this library to non-Rust 
//! languages.

use std::ffi::CStr;
use std::ptr;
use libc::c_char;
use reqwest::{Url, Method};

use Request;


/// Construct a new `Request` which will target the provided URL and fill out 
/// all other fields with their defaults.
/// 
/// # Note
/// 
/// If the string passed in isn't a valid URL this will return a null pointer.
/// 
/// # Safety
/// 
/// Make sure you destroy the request with [`request_destroy()`] once you are
/// done with it.
/// 
/// [`request_destroy()`]: fn.request_destroy.html
#[no_mangle]
pub unsafe extern &quot;C&quot; fn request_create(url: *const c_char) -&gt; *mut Request {
    if url.is_null() {
        return ptr::null_mut();
    }

    let raw = CStr::from_ptr(url);

    let url_as_str = match raw.to_str() {
        Ok(s) =&gt; s,
        Err(_) =&gt; return ptr::null_mut(),
    };

    let parsed_url = match Url::parse(url_as_str) {
        Ok(u) =&gt; u,
        Err(_) =&gt; return ptr::null_mut(),
    };

    let req = Request::new(parsed_url, Method::Get);
    Box::into_raw(Box::new(req))
}
#}</code></pre></pre>
<p>That looks like a large chunk of code, but the vast majority is either
documentation for indicating constraints which need to be maintained, or
error handling. You can see that we use the <code>CStr</code> type from the <code>std::ffi</code>
module which acts as a safe wrapper around a C string. We then convert the
<code>CStr</code> to a normal <code>str</code> which may fail if the string isn't UTF-8, returning
a null pointer (using the <code>ptr::null_mut()</code> helper) to indicate failure.</p>
<p>Converting from a <code>str</code> to a <code>Url</code> is almost identical.</p>
<p>Finally we can create the <code>Request</code> using <code>Request::new()</code>, then box it and
return a raw pointer to the <code>Request</code> to the caller.</p>
<p>We also inserted a check for null pointers at the top as a bit of a sanity
check.</p>
<p>The destructor is significantly easier to write. All we need to do is accept
a raw pointer to some <code>Request</code>, convert it back to a <code>Box</code> with
<code>Box::from_raw()</code>, then the <code>Box&lt;Request&gt;</code> can either be explicitly dropped or
allowed to fall out of scope to destroy it like normal.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

/// Destroy a `Request` once you are done with it.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn request_destroy(req: *mut Request) {
    if !req.is_null() {
        drop(Box::from_raw(req));
    }
}
#}</code></pre></pre>
<p>You will notice that both functions were prefixed with <code>request_</code>. This is a
common convention used to indicate that the function &quot;belongs&quot; to some type,
conceptual the equivalent of a normal method.</p>
<p>Note the new module as a public one in <code>lib.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/lib.rs

pub mod ffi;
#}</code></pre></pre>
<a class="header" href="./basic_request.html#the-c-wrapper" id="the-c-wrapper"><h2>The C++ Wrapper</h2></a>
<p>Although we <em>could</em> use the raw C-style FFI bindings throughout this
application, that usually ends up with non-idiomatic and more error-prone code.
Instead, it'd be really nice if we could use C++'s destructors to ensure memory
gets free'd appropriately, as well as the ability to use methods to group
functions logically.</p>
<p>We'll put the definition for these wrappers in their own <code>wrappers.hpp</code> header
file so the main application only uses the public interface. For now we'll
only create a constructor and destructor.</p>
<pre><code class="language-cpp">// gui/wrappers.hpp

#include &lt;string&gt;

class Request {
public:
  Request(const std::string);
  ~Request();

private:
  void *raw;
};

</code></pre>
<p>The implementation is equally as trivial. It just declares that there are a
couple external functions <em>somewhere</em> that we want to use, and the linker can
resolve them for us at link time.</p>
<pre><code class="language-cpp">// gui/wrappers.cpp

#include &quot;wrappers.hpp&quot;

extern &quot;C&quot; {
void *request_create(const char *);
void request_destroy(void *);
}

Request::Request(const std::string url) {
  raw = request_create(url.c_str());
  if (raw == nullptr) {
    throw &quot;Invalid URL&quot;;
  }
}

Request::~Request() { request_destroy(raw); }
</code></pre>
<blockquote>
<p><strong>Note:</strong> You may have noticed that even though <code>request_create()</code> accepts a
raw C-style string (<code>char *</code>), the <code>Request</code> wrapper's constructor takes in a
normal <code>std::string</code>.</p>
<p>This is what we were talking about earlier about wrappers being more idiomatic
and easier to use. It may sound like a trivial thing now, but in real projects
where the application is much more complex and has many moving parts, an
idiomatic class is much less likely to introduce bugs because the users won't
need to read through a load of source code to see how to use it. Everything
will <em>Just Work</em>.</p>
</blockquote>
<p>We will also need to update the <code>CMakeLists.txt</code> file for our <code>gui/</code> directory
so that these new files are compiled in.</p>
<pre><code class="language-cmake"># gui/CMakeLists.txt

set(CMAKE_CXX_STANDARD 14)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)
find_package(Qt5Widgets)

set(SOURCE main_window.cpp main_window.hpp wrappers.cpp wrappers.hpp main.cpp)
add_executable(gui ${SOURCE})
get_target_property(CLIENT_DIR client LOCATION)
target_link_libraries(gui Qt5::Widgets)
target_link_libraries(gui ${CLIENT_DIR}/libclient.so)
add_dependencies(gui client)
</code></pre>
<p>As a sanity check to make sure everything is working and that memory is being
free'd properly. By far the easiest way to do this is to update the GUI's
click handler to create a new C++ <code>Request</code> and add a bunch of print
statements to <code>ffi.rs</code> to see what actually gets called.</p>
<p>The updated <code>main_window.cpp</code>:</p>
<pre><code class="language-cpp">// gui/main_window.cpp

#include &quot;main_window.hpp&quot;
#include &quot;wrappers.hpp&quot;
#include &lt;iostream&gt;

void MainWindow::onClick() {
  std::cout &lt;&lt; &quot;Creating the request&quot; &lt;&lt; std::endl;
  Request req(&quot;https://google.com/&quot;);
  std::cout &lt;&lt; &quot;Request created in C++&quot; &lt;&lt; std::endl;
}

...
</code></pre>
<p>And <code>ffi.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub unsafe extern &quot;C&quot; fn request_create(url: *const c_char) -&gt; *mut Request {
    ...

    println!(&quot;Request created in Rust: {}&quot;, url_as_str);
    Box::into_raw(Box::new(req))
}

...

#[no_mangle]
pub unsafe extern &quot;C&quot; fn request_destroy(req: *mut Request) {
    if !req.is_null() {
        println!(&quot;Request was destroyed&quot;);
        drop(Box::from_raw(req));
    }
}
#}</code></pre></pre>
<p>If you compile and run the GUI program then click our button you should see
something like the following printed to stdout.</p>
<pre><code>$ cmake .. &amp;&amp; make
$ ./gui/gui
Creating the request
Request created in Rust: https://google.com/
Request created in C++
Request was destroyed
Creating the request
Request created in Rust: https://google.com/
Request created in C++
Request was destroyed
</code></pre>
<p>This tells us that the request is being constructed and that the URL was
passed to Rust correctly, and that it is also being destroyed when the C++
<code>Request</code> falls out of scope.</p>
<p>This little test also shows how easy it is to interoperate between C++ and Rust.
Sure, it may be a little annoying to create wrappers and FFI bindings but
looking at it differently, this allows us to create a very definitive line,
separating the GUI code from the HTTP client module.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./client.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./send_basic.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./client.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./send_basic.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
