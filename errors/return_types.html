<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Return Types - The (unofficial) Rust FFI Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Using unsafe for fun and profit!">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./overview.html"><strong>1.</strong> Overview</a></li><li><a href="./setting_up.html"><strong>2.</strong> Setting Up</a></li><li><a href="./client.html"><strong>3.</strong> Core Client Library</a></li><li><a href="./basic_request.html"><strong>4.</strong> Constructing a Basic Request</a></li><li><a href="./send_basic.html"><strong>5.</strong> Sending the Request</a></li><li><a href="./cbindgen.html"><strong>6.</strong> Generating a Header File</a></li><li><a href="./errors/index.html"><strong>7.</strong> Better Error Handling</a></li><li><ul class="section"><li><a href="./errors/return_types.html" class="active"><strong>7.1.</strong> Return Types</a></li><li><a href="./errors/logging.html"><strong>7.2.</strong> Logging</a></li><li><a href="./errors/exception_safety.html"><strong>7.3.</strong> Exception Safety</a></li></ul></li><li><a href="./async.html"><strong>8.</strong> Asynchronous Operations</a></li><li><a href="./complex_request.html"><strong>9.</strong> More Complex Requests</a></li><li><a href="./testing.html"><strong>10.</strong> Testing</a></li><li><a href="./dynamic_loading.html"><strong>11.</strong> Dynamic Loading &amp; Plugins</a></li><li class="spacer"></li><li><a href="./fun/index.html"><strong>12.</strong> Break All The Things!!1!</a></li><li><ul class="section"><li><a href="./fun/problems.html"><strong>12.1.</strong> Problems</a></li><li><a href="./fun/solutions.html"><strong>12.2.</strong> Solutions</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The (unofficial) Rust FFI Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./errors/return_types.html#return-types" id="return-types"><h1>Return Types</h1></a>
<p>A very powerful error handling mechanism in C-style programs (technically this
is one because our FFI bindings export a C interface) is modelled on <code>errno</code>.</p>
<p>This employs a thread-local variable which holds the most recent error as
well as some convenience functions for getting/clearing this variable. The
theory is if a function fails then it should return an &quot;obviously invalid&quot;
value (typically <code>-1</code> or <code>0</code> when returning integers or <code>null</code> for pointers).
The user can then check for this and consult the most recent error for more
information. Of course that means all fallible operations <em>must</em> update the
most recent error if they fail and that you <em>must</em> check the returned value of
any fallible operation.</p>
<p>While it isn't as elegant as Rust's monad-style <code>Result&lt;T, E&gt;</code> with <code>?</code> and the
various combinators, it actually turns out to be a pretty solid error handling
technique in practice.</p>
<blockquote>
<p><strong>Note:</strong> It is <strong>highly recommended</strong> to have a skim through libgit2's
<a href="https://github.com/libgit2/libgit2/blob/master/docs/error-handling.md">error handling docs</a>. The error handling mechanism we'll be using
takes a lot of inspiration from <code>libgit2</code>.</p>
</blockquote>
<a class="header" href="./errors/return_types.html#working-with-errors" id="working-with-errors"><h2>Working With Errors</h2></a>
<p>We'll start off by defining a thread-local static variable with the
<a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local!()</code></a> macro and put it in the <code>ffi</code> module.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

thread_local!{
    static LAST_ERROR: RefCell&lt;Option&lt;Box&lt;Error&gt;&gt;&gt; = RefCell::new(None);
}
#}</code></pre></pre>
<p>Notice that we haven't declared the error value public, this is so people are
forced to access the error via getter and setter functions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

/// Update the most recent error, clearing whatever may have been there before.
pub fn update_last_error&lt;E: Error + 'static&gt;(err: E) {
    error!(&quot;Setting LAST_ERROR: {}&quot;, err);

    {
        // Print a pseudo-backtrace for this error, following back each error's
        // cause until we reach the root error.
        let mut cause = err.cause();
        while let Some(parent_err) = cause {
            warn!(&quot;Caused by: {}&quot;, parent_err);
            cause = parent_err.cause();
        }
    }

    LAST_ERROR.with(|prev| {
        *prev.borrow_mut() = Some(Box::new(err));
    });
}

/// Retrieve the most recent error, clearing it in the process.
pub fn take_last_error() -&gt; Option&lt;Box&lt;Error&gt;&gt; {
    LAST_ERROR.with(|prev| prev.borrow_mut().take())
}
#}</code></pre></pre>
<p>Neither of these are terribly interesting once you look at the
<a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local!()</code></a> macro's documentation. Notice that the actual type we're
using needs to be <code>RefCell&lt;Option&lt;_&gt;&gt;</code> so we can have both interior mutability,
<em>and</em> represent the fact that there may not have been any recent errors. It's
annoying, but luckily due to the API's design the complexity won't leak into
client code.</p>
<p>While the getters and setters we currently have are quite powerful, it's still
not possible to use them outside of Rust. To remedy this we're going to add a
function that is callable from C and will give the caller the most recent error
message.</p>
<p>The idea is the caller will give us a buffer to write the string into. This
part can be a little tricky because we have a couple edge cases and ergonomics
issues to deal with.</p>
<p>For example, if the caller passing a buffer which isn't big enough to hold the
error message we should return an error, obviously. However how does the caller
know what a reasonable buffer size is to begin with? Making them guess isn't
exactly a practical solution, so it'd be nice if we included a mechanism for
calculating the error message's length without consuming the error message
itself.</p>
<p>To deal with this we add an extra <code>last_error_length()</code> function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

/// Calculate the number of bytes in the last error's error message **not**
/// including any trailing `null` characters.
#[no_mangle]
pub extern &quot;C&quot; fn last_error_length() -&gt; c_int {
    LAST_ERROR.with(|prev| match *prev.borrow() {
        Some(ref err) =&gt; err.to_string().len() as c_int + 1,
        None =&gt; 0,
    })
}
#}</code></pre></pre>
<p>The second issue is more problematic. For all unix-based systems, the string
type used pretty much ubiquitously is UTF-8, meaning we should be able to copy
a Rust <code>String</code>'s contents directly into the provided buffer without any issues.
<em>However</em>, the &quot;unicode&quot; string type most commonly used on Windows is <strong>not</strong>
UTF-8. Instead they use UTF-16 (well... technically <a href="https://users.rust-lang.org/t/x-post-how-do-i-integrate-rust-into-other-projects/13507/5?u=michael-f-bryan">it's not even valid
UTF-16</a>) which is completely incompatible with UTF-8.</p>
<p>Therefore on Windows if we want to be correct we should convert the <code>String</code>
representation of an error message into a native Windows string with
<code>encode_wide()</code> from <a href="https://doc.rust-lang.org/std/os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide"><code>std::os::windows::ffi::OsStrExt</code></a> and copy that
into a <code>&amp;mut [u16]</code> buffer (not <code>&amp;mut [u8]</code>!) that the user gives to us... Eww.</p>
<p>There's no easy way to get around this without a bunch of conditional
compilation (<code>#[cfg]</code>) and adding a lot of complexity to the implementation,
therefore we're going to cheat and say it's the caller's responsibility to deal
with any UTF-8/UTF-16 conversions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

/// Write the most recent error message into a caller-provided buffer as a UTF-8
/// string, returning the number of bytes written.
///
/// # Note
///
/// This writes a **UTF-8** string into the buffer. Windows users may need to
/// convert it to a UTF-16 &quot;unicode&quot; afterwards.
///
/// If there are no recent errors then this returns `0` (because we wrote 0
/// bytes). `-1` is returned if there are any errors, for example when passed a
/// null pointer or a buffer of insufficient size.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn last_error_message(buffer: *mut c_char, length: c_int) -&gt; c_int {
    if buffer.is_null() {
        warn!(&quot;Null pointer passed into last_error_message() as the buffer&quot;);
        return -1;
    }

    let last_error = match take_last_error() {
        Some(err) =&gt; err,
        None =&gt; return 0,
    };

    let error_message = last_error.to_string();

    let buffer = slice::from_raw_parts_mut(buffer as *mut u8, length as usize);

    if error_message.len() &gt;= buffer.len() {
        warn!(&quot;Buffer provided for writing the last error message is too small.&quot;);
        warn!(
            &quot;Expected at least {} bytes but got {}&quot;,
            error_message.len() + 1,
            buffer.len()
        );
        return -1;
    }

    ptr::copy_nonoverlapping(
        error_message.as_ptr(),
        buffer.as_mut_ptr(),
        error_message.len(),
    );

    // Add a trailing null so people using the string as a `char *` don't
    // accidentally read into garbage.
    buffer[error_message.len()] = 0;

    error_message.len() as c_int
}
#}</code></pre></pre>
<p>Our <code>last_error_message()</code> function turned out to be rather long, although most
of it is taken up by checking for errors and edge cases.</p>
<blockquote>
<p><strong>Note:</strong> Notice that we're writing into a buffer provided by the caller
instead of returning a Rust <code>String</code>. This makes memory management a lot
easier because the caller can clean up the buffer like normal instead of
needing to remember to call some Rust destructor afterwards.</p>
<p>Writing into borrowed buffers instead of returning an owned object is a common
pattern when doing FFI. It helps simplify things and avoid errors due to
object lifetimes (in general, not just in the Rust sense of the word) and
forgetting to call destructors.</p>
</blockquote>
<a class="header" href="./errors/return_types.html#adding-update_last_error-to-the-ffi-bindings" id="adding-update_last_error-to-the-ffi-bindings"><h2>Adding <code>update_last_error()</code> To The FFI Bindings</h2></a>
<p>Now we've got a shiny new error handling mechanism, we need to go back over the
FFI bindings in <code>client/src/ffi.rs</code> and make sure any fallible operations set
call <code>update_last_error()</code> when they fail.</p>
<p>Because we are using <code>error-chain</code> for error handling in Rust, we've got the
ability to add extra context to errors before calling <code>update_last_error()</code>,
automatically updating the error's <code>cause</code>.</p>
<p>For example, you may refactor the <code>request_create()</code> function to look something
like this:</p>
<pre><code class="language-diff">// client/src/ffi.rs

#[no_mangle]
 pub unsafe extern &quot;C&quot; fn request_create(url: *const c_char) -&gt; *mut Request {
     if url.is_null() {
+        let err = Error::from(&quot;No URL provided&quot;);
+        update_last_error(err);
         return ptr::null_mut();
     }
 
     let raw = CStr::from_ptr(url);
 
      let url_as_str = match raw.to_str() {
          Ok(s) =&gt; s,
-        Err(_) =&gt; return ptr::null_mut(),
+        Err(e) =&gt; {
+            let err = Error::with_chain(e, &quot;Unable to convert URL to a UTF-8 string&quot;);
+            update_last_error(err);
+            return ptr::null_mut();
+        }
      };
 
      let parsed_url = match Url::parse(url_as_str) {
          Ok(u) =&gt; u,
-        Err(_) =&gt; return ptr::null_mut(),
+        Err(e) =&gt; {
+            let err = Error::with_chain(e, &quot;Unable to parse the URL&quot;);
+            update_last_error(err);
+            return ptr::null_mut();
+        }
      };

    ...
</code></pre>
<p>For brevity's sake, we won't show how <em>all</em> the FFI bindings have been updated
because it's largely tedious refactoring. However, feel free to inspect the
<a href="TODO-update-me!">source code</a> for this guide if you are curious to see the final version.</p>
<a class="header" href="./errors/return_types.html#c-error-bindings" id="c-error-bindings"><h2>C++ Error Bindings</h2></a>
<p>We're going to expose this error handling mechanism to C++ in two ways, there
will be a low level C++ equivalent to <code>last_error_message()</code> which simply calls
the Rust function and does the necessary work to convert the error message into
a <code>std::string</code>.</p>
<p>There will also be a more high-level <code>WrapperException</code> class which can be thrown
whenever an operation fails. This should then be caught higher up by the Qt
application and an appropriate error message will be displayed to the user.</p>
<p>First we need to add <code>last_error_message()</code> to our <code>wrappers.hpp</code> header file.</p>
<pre><code class="language-cpp">// gui/wrappers.hpp

std::string last_error_message();
</code></pre>
<p>Then we need to implement it.</p>
<pre><code class="language-cpp">// gui/wrappers.cpp

std::string last_error_message() {
  int error_length = ffi::last_error_length();

  if (error_length == 0) {
    return std::string();
  }

  std::string msg(error_length, '\0');
  int ret = ffi::last_error_message(&amp;msg[0], msg.length());
  if (ret &lt;= 0) {
    // If we ever get here it's a bug
    throw new WrapperException(&quot;Fetching error message failed&quot;);
  }

  return msg;
}
</code></pre>
<p>Notice that if there was no error we return an empty <code>std::string</code> instead of
blowing up.</p>
<p>We also want to define a <code>WrapperException</code> class in the <code>wrappers.hpp</code> header
file. To make things easier, we're defining a public static helper function
which will create a new <code>WrapperException</code> from the most recent error.</p>
<pre><code class="language-cpp">// gui/wrappers.hpp

class WrapperException : std::exception {
public:
  WrapperException(const std::string&amp; msg) : msg(msg){};
  static WrapperException last_error();
  const char * what () const throw () {
      return msg.c_str();
   }

private:
  std::string msg;
};
</code></pre>
<p>The <code>last_error()</code> method has a fairly simple definition, it fetches the last
error message and creates a new <code>WrapperException</code> with it. If the error message
was empty then we use a default message.</p>
<pre><code class="language-cpp">// gui/wrappers.cpp

WrapperException WrapperException::last_error() {
  std::string msg = last_error_message();

  if (msg.length == 0) {
    return WrapperException(&quot;(no error available)&quot;);
  } else {
    return WrapperException(msg);
  }
}
</code></pre>
<a class="header" href="./errors/return_types.html#integrating-in-the-error-handling-mechanism" id="integrating-in-the-error-handling-mechanism"><h2>Integrating In The Error Handling Mechanism</h2></a>
<p>Now we've got a proper error handling mechanism, we need to go back and make
sure everything uses it. This is just a case of finding all <code>throw</code>
statements in <code>wrappers.cpp</code> (using <code>grep</code> or your editor's &quot;find&quot; function)
and converting them to use <code>throw WrapperException::last_error()</code>.</p>
<p>The easiest way to check our error handling mechanism is to edit the click
handler we've been using for testing and make it try to send a request to some
invalid URL.</p>
<pre><code class="language-cpp">// gui/main_window.cpp

void MainWindow::onClick() {
  Request req(&quot;this is an invalid URL&quot;);
}
</code></pre>
<p>Now run the program and click the button.</p>
<pre><code>$ ./gui/gui
...
terminate called after throwing an instance of 'WrapperException'
[1]    1016 abort (core dumped)  ./gui/gui
</code></pre>
<p>It... aborts?</p>
<p>This is because Qt, by default, won't try to catch any thrown exceptions,
meaning they'll just bubble up to the top of the program and crash.</p>
<p>It'd be a much better user experience if the GUI would catch all thrown
exceptions and pop up a nice dialog box saying what went wrong.</p>
<p>According to <a href="http://doc.qt.io/qt-5/exceptionsafety.html#signals-and-slots">Qt's documentation on exceptions</a>, it is undefined behaviour
when a handler throws an exception. In this case it looks like the exception
bubbled up the stack, unhandled, until it hit the program's entry point and
triggered an abort. This isn't exactly ideal, so how about we wrap the click
hander's contents in a big try/catch block?</p>
<pre><code class="language-cpp">// gui/main_window.cpp

void MainWindow::onClick() {
  try
  {
    Request req(&quot;this is an invalid URL&quot;);
  }
  catch (const WrapperException&amp; e)
  {
    QMessageBox::warning(this, &quot;Error&quot;, e.what());
  }
}
</code></pre>
<p>That's much better. Now our application can deal with errors in a sane way, and
is much more robust.</p>
<blockquote>
<p><strong>TODO:</strong> Add the error handling patterns developed in this chapter to the
<a href="https://github.com/Michael-F-Bryan/ffi-helpers">ffi-helpers</a> crate.</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./errors/index.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./errors/logging.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./errors/index.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./errors/logging.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
