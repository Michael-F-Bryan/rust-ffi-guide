<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Dynamic Loading &amp; Plugins - The (unofficial) Rust FFI Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Using unsafe for fun and profit!">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./overview.html"><strong>1.</strong> Overview</a></li><li><a href="./setting_up.html"><strong>2.</strong> Setting Up</a></li><li><a href="./client.html"><strong>3.</strong> Core Client Library</a></li><li><a href="./basic_request.html"><strong>4.</strong> Constructing a Basic Request</a></li><li><a href="./send_basic.html"><strong>5.</strong> Sending the Request</a></li><li><a href="./cbindgen.html"><strong>6.</strong> Generating a Header File</a></li><li><a href="./errors/index.html"><strong>7.</strong> Better Error Handling</a></li><li><ul class="section"><li><a href="./errors/return_types.html"><strong>7.1.</strong> Return Types</a></li><li><a href="./errors/logging.html"><strong>7.2.</strong> Logging</a></li><li><a href="./errors/exception_safety.html"><strong>7.3.</strong> Exception Safety</a></li></ul></li><li><a href="./async.html"><strong>8.</strong> Asynchronous Operations</a></li><li><a href="./complex_request.html"><strong>9.</strong> More Complex Requests</a></li><li><a href="./testing.html"><strong>10.</strong> Testing</a></li><li><a href="./dynamic_loading.html" class="active"><strong>11.</strong> Dynamic Loading &amp; Plugins</a></li><li class="spacer"></li><li><a href="./fun/index.html"><strong>12.</strong> Break All The Things!!1!</a></li><li><ul class="section"><li><a href="./fun/problems.html"><strong>12.1.</strong> Problems</a></li><li><a href="./fun/solutions.html"><strong>12.2.</strong> Solutions</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The (unofficial) Rust FFI Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./dynamic_loading.html#dynamic-loading--plugins" id="dynamic-loading--plugins"><h1>Dynamic Loading &amp; Plugins</h1></a>
<p>What application wouldn't be complete without the ability to add user-defined
plugins? In this chapter we take a small detour to visit the concept of
dynamically loading a library at runtime and registering it with our parent
application.</p>
<p>The end goal is to allow users to provide a shared library (DLL, <code>*.so</code>, etc)
which contains a set of pre-defined functions. These functions will then allow
us to manipulate a request before it is sent and then manipulate/inspect the
response before displaying it to the user.</p>
<p>From the Rust side of things, by far the easiest way to establish this is to
define a <code>Plugin</code> trait which does the various manipulations, then add in a
macro users can run which will define all the <code>unsafe</code> function declarations.</p>
<p>Our <code>Plugin</code> trait may look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Plugin {
    fn name(&amp;self) -&gt; &amp;'static str;
    fn on_plugin_load(&amp;self) {}
    fn pre_send(&amp;self, _request: &amp;mut Request) {}
    fn post_receive(&amp;self, _response: &amp;mut Response) {}
}
#}</code></pre></pre>
<p>The macro would then declare an <code>extern &quot;C&quot;</code> constructor which exports a trait
object (<code>Box&lt;Plugin&gt;</code>) with some pre-defined symbol (e.g. <code>_plugin_create()</code>).</p>
<blockquote>
<p><strong>Note:</strong> This is actually the exact pattern used by the Linux kernel for
loading device drivers. Each driver must expose a function which returns a
vtable (struct of function pointers) that define the various commands
necessary for talking with a device (read, write, etc).</p>
</blockquote>
<p>Before diving into the complexity of real code, it's probably going to be easier
if we figure out how dynamic loading works using a contrived example.</p>
<a class="header" href="./dynamic_loading.html#contrived-example" id="contrived-example"><h2>Contrived Example</h2></a>
<p>For this the function being exported doesn't need to be very interesting, seeing
it's just an example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn add(a: isize, b: isize) -&gt; isize {
    a + b
}
#}</code></pre></pre>
<p>This then can then be compiled into a <code>cdylib</code>.</p>
<blockquote>
<p><strong>Note:</strong> Up uptil now it hasn't mattered whether you compile as a dynamic
library or a static one. However for dynamically loading a library on the fly
you <strong>must</strong> compile as a <code>cdylib</code>.</p>
</blockquote>
<pre><code class="language-bash">$ rustc --crate-type cdylib adder.rs
</code></pre>
<p>The symbols exported by this dynamic library can now be inspected using the
<code>nm</code> tool from GNU <code>binutils</code>.</p>
<pre><code class="language-bash">$ nm libadder.so | grep 'add'
00000000000005f0 T add
</code></pre>
<p>As you can see, the <code>add</code> function is exposed and fully accessible to other
programs.</p>
<a class="header" href="./dynamic_loading.html#loading-the-contrived-example" id="loading-the-contrived-example"><h2>Loading the Contrived Example</h2></a>
<p>Loading a function from this library and then calling it is then surprisingly
easy. The key is to use something like the <a href="https://crates.io/crates/libloading">libloading</a> crate. This abstracts
over the various mechanisms provided by the operating system for dynamically
loading a library.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate libloading;

use std::env;
use libloading::{Library, Symbol};
#}</code></pre></pre>
<p>It's also a good idea to add a type alias for the <code>add()</code> function's signature.
This isn't required, but when things start getting more complex and having more
interesting arguments the extra readability really pays off.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type AddFunc = unsafe fn(isize, isize) -&gt; isize;
#}</code></pre></pre>
<p>The <code>main()</code> function takes the DLL as its first command line argument:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let library_path = env::args().nth(1).expect(&quot;USAGE: loading &lt;LIB&gt;&quot;);
    println!(&quot;Loading add() from {}&quot;, library_path);
</code></pre></pre>
<p>Loads the library and gets a symbol (casting the function pointer so it has the
desired signature)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let lib = Library::new(library_path).unwrap();

    unsafe {
        let func: Symbol&lt;AddFunc&gt; = lib.get(b&quot;add&quot;).unwrap();
#}</code></pre></pre>
<p>Then you can finally call the imported function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        let answer = func(1, 2);
        println!(&quot;1 + 2 = {}&quot;, answer);
    }
}
#}</code></pre></pre>
<p>Now compiling and running with cargo gives exactly what we'd expect:</p>
<pre><code class="language-bash">$ cargo run -- ../libadder.so
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/loading ../libadder.so`
Loading add() from ../libadder.so
1 + 2 = 3
</code></pre>
<p>The entire <code>main.rs</code> looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libloading;

use std::env;
use libloading::{Library, Symbol};

type AddFunc = fn(isize, isize) -&gt; isize;

fn main() {
    let library_path = env::args().nth(1).expect(&quot;USAGE: loading &lt;LIB&gt;&quot;);
    println!(&quot;Loading add() from {}&quot;, library_path);

    let lib = Library::new(library_path).unwrap();

    unsafe {
        let func: Symbol&lt;AddFunc&gt; = lib.get(b&quot;add&quot;).unwrap();

        let answer = func(1, 2);
        println!(&quot;1 + 2 = {}&quot;, answer);
    }
}
</code></pre></pre>
<a class="header" href="./dynamic_loading.html#setting-up-plugins" id="setting-up-plugins"><h2>Setting Up Plugins</h2></a>
<p>Now that we have a better understanding of how dynamically loading a library on
the fly works, we can start adding plugins to our application.</p>
<p>First we'll define a <code>Plugin</code> trait which all plugins must implement. This has
been copied pretty much verbatim from the beginning of the chapter.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

use std::ffi::OsStr;
use std::any::Any;
use libloading::{Library, Symbol};

use errors::*;
use {Request, Response};


/// A plugin which allows you to add extra functionality to the REST client.
pub trait Plugin: Any + Send + Sync {
    /// Get a name describing the `Plugin`.
    fn name(&amp;self) -&gt; &amp;'static str;
    /// A callback fired immediately after the plugin is loaded. Usually used 
    /// for initialization.
    fn on_plugin_load(&amp;self) {}
    /// A callback fired immediately before the plugin is unloaded. Use this if
    /// you need to do any cleanup.
    fn on_plugin_unload(&amp;self) {}
    /// Inspect (and possibly mutate) the request before it is sent.
    fn pre_send(&amp;self, _request: &amp;mut Request) {}
    /// Inspect and/or mutate the received response before it is displayed to
    /// the user.
    fn post_receive(&amp;self, _response: &amp;mut Response) {}
}
#}</code></pre></pre>
<p>This is all pretty standard. Notice that the <code>Plugin</code> <em>must</em> be sendable between
threads and that all callbacks take <code>&amp;self</code> instead of <code>&amp;mut self</code>. This means
that any mutation must be done using interior mutability. the <code>Send + Sync</code>
bound also means you need to use the appropriate synchronisation mechanisms
(e.g. a <code>Mutex</code>).</p>
<p>We also define a convenience macro that users can call to export their <code>Plugin</code>
in a safe manner. This just declares a new <code>extern &quot;C&quot;</code> function called
<code>_plugin_create()</code> which will call the constructor and return a new boxed
<code>Plugin</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

/// Declare a plugin type and its constructor.
///
/// # Notes
///
/// This works by automatically generating an `extern &quot;C&quot;` function with a
/// pre-defined signature and symbol name. Therefore you will only be able to
/// declare one plugin per library.
#[macro_export]
macro_rules! declare_plugin {
    ($plugin_type:ty, $constructor:path) =&gt; {
        #[no_mangle]
        pub extern &quot;C&quot; fn _plugin_create() -&gt; *mut $crate::Plugin {
            // make sure the constructor is the correct type.
            let constructor: fn() -&gt; $plugin_type = $constructor;

            let object = constructor();
            let boxed: Box&lt;$crate::Plugin&gt; = Box::new(object);
            Box::into_raw(boxed)
        }
    };
}
#}</code></pre></pre>
<p>Another thing we're going to need is a way to manage plugins and make sure they
are called at the appropriate time. This is usually done with a <code>PluginManager</code>.</p>
<p>Something we need to keep in mind is that any <code>Library</code> we load will need to
outlive our plugins. This is because they contain the code for executing the
various <code>Plugin</code> methods, so if the <code>Library</code> is dropped too early our plugins'
vtable could end up pointing at garbage... Which would be bad.</p>
<p>First lets add the struct definition and a constructor,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

pub struct PluginManager {
    plugins: Vec&lt;Box&lt;Plugin&gt;&gt;,
    loaded_libraries: Vec&lt;Library&gt;,
}

impl PluginManager {
    pub fn new() -&gt; PluginManager {
        PluginManager {
            plugins: Vec::new(),
            loaded_libraries: Vec::new(),
        }
    }
#}</code></pre></pre>
<p>Next comes the actual plugin loading part. Make sure to add <code>libloading</code> as a
dependency to your <code>Cargo.toml</code>, then we can use it to dynamically load the
plugin and call the <code>_plugin_create()</code> function. We also need to make sure
the <code>on_plugin_load()</code> callback is fired so the plugin has a chance to do any
necessary initialization.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

    pub unsafe fn load_plugin&lt;P: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, filename: P) -&gt; Result&lt;()&gt; {
        type PluginCreate = unsafe fn() -&gt; *mut Plugin;

        let lib = Library::new(filename.as_ref()).chain_err(|| &quot;Unable to load the plugin&quot;)?;

        // We need to keep the library around otherwise our plugin's vtable will
        // point to garbage. We do this little dance to make sure the library
        // doesn't end up getting moved.
        self.loaded_libraries.push(lib);

        let lib = self.loaded_libraries.last().unwrap();

        let constructor: Symbol&lt;PluginCreate&gt; = lib.get(b&quot;_plugin_create&quot;)
            .chain_err(|| &quot;The `_plugin_create` symbol wasn't found.&quot;)?;
        let boxed_raw = constructor();

        let plugin = Box::from_raw(boxed_raw);
        debug!(&quot;Loaded plugin: {}&quot;, plugin.name());
        plugin.on_plugin_load();
        self.plugins.push(plugin);


        Ok(())
    }
#}</code></pre></pre>
<p>Now our <code>PluginManager</code> can load plugins, we need to make sure it has methods
for firing the various plugin callbacks.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

    /// Iterate over the plugins, running their `pre_send()` hook.
    pub fn pre_send(&amp;mut self, request: &amp;mut Request) {
        debug!(&quot;Firing pre_send hooks&quot;);

        for plugin in &amp;mut self.plugins {
            trace!(&quot;Firing pre_send for {:?}&quot;, plugin.name());
            plugin.pre_send(request);
        }
    }

    /// Iterate over the plugins, running their `post_receive()` hook.
    pub fn post_receive(&amp;mut self, response: &amp;mut Response) {
        debug!(&quot;Firing post_receive hooks&quot;);

        for plugin in &amp;mut self.plugins {
            trace!(&quot;Firing post_receive for {:?}&quot;, plugin.name());
            plugin.post_receive(response);
        }
    }

    /// Unload all plugins and loaded plugin libraries, making sure to fire 
    /// their `on_plugin_unload()` methods so they can do any necessary cleanup.
    pub fn unload(&amp;mut self) {
        debug!(&quot;Unloading plugins&quot;);

        for plugin in self.plugins.drain(..) {
            trace!(&quot;Firing on_plugin_unload for {:?}&quot;, plugin.name());
            plugin.on_plugin_unload();
        }

        for lib in self.loaded_libraries.drain(..) {
            drop(lib);
        }
    }
}
#}</code></pre></pre>
<p>Those last three methods should be fairly self-explanatory.</p>
<p>Something else we may want to do is add a <code>Drop</code> impl so that our plugins are
always unloaded when the <code>PluginManager</code> gets dropped. This gives them a chance
to do any necessary cleanup.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/plugins.rs

impl Drop for PluginManager {
    fn drop(&amp;mut self) {
        if !self.plugins.is_empty() || !self.loaded_libraries.is_empty() {
            self.unload();
        }
    }
}
#}</code></pre></pre>
<p>A thing to keep in mind is something called <a href="https://www.reddit.com/r/rust/comments/4a9vu6/what_are_the_semantics_of_panicondrop/">panic-on-drop</a>. Basically, if the
program is panicking it'll unwind the stack, calling destructors when necessary.
However, because our <code>PluginManager</code> tries to unload plugins if it hasn't
already, a <code>Plugin</code> who's <code>unload()</code> method <strong>also</strong> panics will result in a
second panic. This usually results in aborting the entire program because your
program is most probably FUBAR.</p>
<p>To prevent this, we'll want to make sure the C++ code explicitly unloads the
plugin manager before destroying it.</p>
<a class="header" href="./dynamic_loading.html#writing-c-bindings" id="writing-c-bindings"><h2>Writing C++ Bindings</h2></a>
<p>As usual, once we've added a piece of functionality to the core Rust crate we'll
need to expose it to C++ in our <code>ffi</code> module, then add the C++ bindings to
<code>wrappers.cpp</code>.</p>
<p>Writing FFI bindings should be quite familiar by now. All you are doing is
converting raw pointers into references, then calling a method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

use PluginManager;

...

/// Create a new `PluginManager`.
#[no_mangle]
pub extern &quot;C&quot; fn plugin_manager_new() -&gt; *mut PluginManager {
    Box::into_raw(Box::new(PluginManager::new()))
}

/// Destroy a `PluginManager` once you are done with it.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn plugin_manager_destroy(pm: *mut PluginManager) {
    if !pm.is_null() {
        let pm = Box::from_raw(pm);
        drop(pm);
    }
}

/// Unload all loaded plugins.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn plugin_manager_unload(pm: *mut PluginManager) {
    let pm = &amp;mut *pm;
    pm.unload();
}

/// Fire the `pre_send` plugin hooks.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn plugin_manager_pre_send(pm: *mut PluginManager, request: *mut Request) {
    let pm = &amp;mut *pm;
    let request = &amp;mut *request;
    pm.pre_send(request);
}

/// Fire the `post_receive` plugin hooks.
#[no_mangle]
pub unsafe extern &quot;C&quot; fn plugin_manager_post_receive(
    pm: *mut PluginManager,
    response: *mut Response,
) {
    let pm = &amp;mut *pm;
    let response = &amp;mut *response;
    pm.post_receive(response);
}

#}</code></pre></pre>
<p>Plugin loading is a bit more interesting because we need to convert a
<code>*const c_char</code> into a <code>&amp;str</code>, but other than that it's all pretty
straightforward.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/ffi.rs

#[no_mangle]
pub unsafe extern &quot;C&quot; fn plugin_manager_load_plugin(
    pm: *mut PluginManager,
    filename: *const c_char,
) -&gt; c_int {
    let pm = &amp;mut *pm;
    let filename = CStr::from_ptr(filename);
    let filename_as_str = match filename.to_str() {
        Ok(s) =&gt; s,
        Err(_) =&gt; {
            // TODO: proper error handling
            return -1;
        }
    };

    // TODO: proper error handling and catch_unwind
    match pm.load_plugin(filename_as_str) {
        Ok(_) =&gt; 0,
        Err(_) =&gt; -1,
    }
}
#}</code></pre></pre>
<p>Next we need to add a <code>PluginManager</code> wrapper class to our <code>wrappers.hpp</code>. We
should also say that <code>PluginManager</code> is a <code>friend</code> of <code>Request</code> and <code>Response</code>
so it can access their raw pointers.</p>
<pre><code class="language-cpp">// gui/wrappers.hpp

class Request {
  friend class PluginManager;
  ...
};

class Response {
  friend class PluginManager;
  ...
};

class PluginManager {
public:
  PluginManager();
  ~PluginManager();
  void unload();
  void pre_send(Request&amp; req);
  void post_receive(Response&amp; res);

private:
  ffi::PluginManager *raw;
};
</code></pre>
<p>Similar to when we were writing the Rust FFI bindings, on the C++ side you just
need to make sure the arguments are in the right shape before deferring to the
corresponding functions.</p>
<pre><code class="language-cpp">// gui/wrappers.cpp

PluginManager::PluginManager() { raw = ffi::plugin_manager_new(); }

PluginManager::~PluginManager() { ffi::plugin_manager_destroy(raw); }

void PluginManager::unload() { ffi::plugin_manager_unload(raw); }

void PluginManager::pre_send(Request&amp; req) {
  ffi::plugin_manager_pre_send(raw, req.raw);
}

void PluginManager::post_receive(Response&amp; res) {
  ffi::plugin_manager_post_receive(raw, res.raw);
}
</code></pre>
<a class="header" href="./dynamic_loading.html#hooking-up-the-plugin-manager" id="hooking-up-the-plugin-manager"><h2>Hooking Up The Plugin Manager</h2></a>
<p>Now that our <code>PluginManager</code> is <em>finally</em> accessible from the GUI we can thread
it through the request sending process.</p>
<p>First we'll need to add the <code>PluginManager</code> to our main window.</p>
<pre><code class="language-diff">// gui/main_window.hpp

#include &quot;wrappers.hpp&quot;

...

class MainWindow : public QMainWindow {
  ...

private:
  ...
  PluginManager pm;
};
</code></pre>
<p>Next we need to make sure that whenever we send a request we also pass it to the
plugin manager so it can do the appropriate pre/post processing.</p>
<pre><code class="language-cpp">...

pm.pre_send(req);
Response res = req.send();
pm.post_receive(res);

...
</code></pre>
<p>We also want to make sure that plugins are unloaded when the window is closed,
the easiest way to do this is to override <code>MainWindow</code>'s <code>closeEvent()</code> method.</p>
<p>To do this we update the <code>main_window.hpp</code> header file:</p>
<pre><code class="language-cpp">// gui/main_window.hpp

class MainWindow : public QMainWindow {
  ...

protected:
  void closeEvent(QCloseEvent *event) override;

  ...
};
</code></pre>
<p>Then add the implementation to <code>main-window.cpp</code>.</p>
<pre><code class="language-cpp">// gui/main_window.cpp

void MainWindow::closeEvent(QCloseEvent *event) {
  pm.unload();
  QMainWindow::closeEvent(event);
}
</code></pre>
<p>Now the plugin manager is plumbed into the existing request pipeline, we need a
way of actually loading plugins at runtime. We'll use a simple <a href="http://doc.qt.io/qt-5/qfiledialog.html">file dialog</a> and
button for this.</p>
<blockquote>
<p><strong>TODO:</strong> Once the main UI is done, step through adding a &quot;load plugin&quot; button
and hooking it up to the plugin manager.</p>
</blockquote>
<a class="header" href="./dynamic_loading.html#lets-make-a-plugin" id="lets-make-a-plugin"><h2>Lets Make A Plugin</h2></a>
<p>Now we have all the plugin infrastructure set up lets actually make (and load) a
plugin! This plugin will inject a special header into each request, then if it's
also present in the response we'll remove it so it's not viewable by the end
user.</p>
<p>First lets create a new library.</p>
<pre><code>$ cargo new injector-plugin
</code></pre>
<p>We also want to update the <code>Cargo.toml</code> to depend on the <code>client</code> library and
generate a <code>cdylib</code> so it's loadable by our plugin manager. While we're at it,
add the <code>log</code> crate so we can log what's happening.</p>
<pre><code class="language-diff">// injector-plugin/Cargo.toml

[package]
name = &quot;injector-plugin&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Michael Bryan &lt;michaelfbryan@gmail.com&gt;&quot;]
+ description = &quot;A plugin which will stealthily inject a special header into your requests.&quot;

[dependencies]
+ log = &quot;0.3.8&quot;
+ client = { path = &quot;../client&quot;}
+
+ [lib]
+ crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<p>We also want to add a <code>cmake</code> build rule so the <code>injector-plugin</code> crate is built
along with the rest of the project. The <code>CMakeLists.txt</code> file for this crate is
identical to the one we wrote for <code>client</code> so just copy that across and change
the relevant names.</p>
<pre><code>$ cp ./client/CMakeLists.txt ./injector-plugin/CMakeLists.txt
</code></pre>
<p>Don't forget to make sure <code>cmake</code> includes the <code>injector-plugin</code> directory!</p>
<pre><code class="language-diff"># ./CMakeLists.txt

add_subdirectory(client)
+ add_subdirectory(injector-plugin)
add_subdirectory(gui)
</code></pre>
<p>As we link the plugin to the <code>client</code> library the Rust way, we need adjust its
<code>Cargo.toml</code> to generate it also as <code>rlib</code>.</p>
<pre><code class="language-toml"># client/Cargo.toml

...

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<p>And then we do a quick build as a sanity check to make sure everything built.</p>
<pre><code>$ mkdir build &amp;&amp; cd build
$ cmake -DCMAKE_BUILD_TYPE=Debug ..
$ make

...
</code></pre>
<p>The plugin body itself isn't overly interesting.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// injector-plugin/src/lib.rs

#[macro_use]
extern crate log;
#[macro_use]
extern crate client;

use std::str;
use client::{Request, Response, Plugin};


#[derive(Debug, Default)]
pub struct Injector;

impl Plugin for Injector {
    fn name(&amp;self) -&gt; &amp;'static str  {
        &quot;Header Injector&quot;
    }

    fn on_plugin_load(&amp;self) {
        info!(&quot;Injector loaded&quot;);
    }

    fn on_plugin_unload(&amp;self) {
        info!(&quot;Injector unloaded&quot;);
    }

    fn pre_send(&amp;self, req: &amp;mut Request) {
        req.headers.set_raw(&quot;some-dodgy-header&quot;, &quot;true&quot;);
        debug!(&quot;Injected header into Request, {:?}&quot;, req);
    }

    fn post_receive(&amp;self, res: &amp;mut Response) {
        debug!(&quot;Received Response&quot;);
        debug!(&quot;Headers: {:?}&quot;, res.headers);
        if res.body.len() &lt; 100 &amp;&amp; log_enabled!(log::LogLevel::Debug) {
            if let Ok(body) = str::from_utf8(&amp;res.body) {
                debug!(&quot;Body: {:?}&quot;, body);
            }
        }
        res.headers.remove_raw(&quot;some-dodgy-header&quot;);
    }
}
#}</code></pre></pre>
<p>Finally, to make this plugin library actually work we need to call the
<code>declare_plugin!()</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// injector-plugin/src/lib.rs

declare_plugin!(Injector, Injector::default);
#}</code></pre></pre>
<p>If you then compile this and inspect it with our trusty <code>nm</code> tool you'll see
that the library contains our <code>_plugin_create</code> symbol.</p>
<pre><code>$ cd build
$ make
$ nm injector-plugin/libinjector_plugin.so | grep ' T '

...
0000000000030820 T _plugin_create
...
</code></pre>
<a class="header" href="./dynamic_loading.html#running-the-plugin" id="running-the-plugin"><h2>Running The Plugin</h2></a>
<p>Now that we've got a plugin and everything is hooked up to the GUI, we can try
it out and benefit from all the hard work put in so far.</p>
<p>Make sure to do one last compile,</p>
<pre><code>$ cd build
$ make
</code></pre>
<p>Then run the GUI and load the plugin from
<code>build/injector-plugin/libinjector_plugin.so</code>. To see what headers are sent you
can send a <code>GET</code> request to http://httpbin.org/get. With any luck you should
see something like this:</p>
<pre><code>$ RUST_LOG=client=debug,injector_plugin=debug ./gui/gui

DEBUG:client::ffi: Loading plugin, &quot;/home/michael/Documents/ffi-guide/build/injector-plugin/libinjector_plugin.so&quot;
DEBUG:client::plugins: Loaded plugin: Header Injector
INFO:injector_plugin: Injector loaded
Creating the request
Sending Request
DEBUG:client::plugins: Firing pre_send hooks
DEBUG:injector_plugin: Injected header into Request, Request { destination: &quot;http://httpbin.org/get&quot;, method: Get, headers: {&quot;some-dodgy-header&quot;: &quot;true&quot;}, cookies: CookieJar { original_cookies: {}, delta_cookies: {} }, body: None }
INFO:client: Sending a GET request to http://httpbin.org/get
DEBUG:client: Sending 1 Headers
DEBUG:client: 	some-dodgy-header: true
DEBUG:client::ffi: Received Response
DEBUG:client::plugins: Firing post_receive hooks
DEBUG:injector_plugin: Received Response
DEBUG:injector_plugin: Headers: {&quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Server&quot;: &quot;meinheld/0.6.1&quot;, &quot;Date&quot;: &quot;Tue, 07 Nov 2017 14:29:39 GMT&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Credentials&quot;: &quot;true&quot;, &quot;X-Powered-By&quot;: &quot;Flask&quot;, &quot;X-Processed-Time&quot;: &quot;0.000864028930664&quot;, &quot;Content-Length&quot;: &quot;303&quot;, &quot;Via&quot;: &quot;1.1 vegur&quot;}
Received Response
Body:
{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, 
    &quot;Connection&quot;: &quot;close&quot;, 
    &quot;Cookie&quot;: &quot;&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Some-Dodgy-Header&quot;: &quot;true&quot;, 
    &quot;User-Agent&quot;: &quot;reqwest/0.8.0&quot;
  }, 
  &quot;origin&quot;: &quot;122.151.115.164&quot;, 
  &quot;url&quot;: &quot;http://httpbin.org/get&quot;
}

DEBUG:client::plugins: Unloading plugins
INFO:injector_plugin: Injector unloaded
</code></pre>
<p>Now if you look <em>very</em> carefully you'll see that the plugin was indeed fired at
the correct time, and <code>httpbin</code> replied saying we had <code>Some-Dodgy-Header</code> in our
headers. If you've stayed with us up to this point then give yourself a pat on
the back, you just accomplished one of the most difficult FFI tasks possible!</p>
<p>If dynamic loading is still confusing you, you may want to check out some of
these links:</p>
<ul>
<li><a href="https://eli.thegreenplace.net/2012/08/24/plugins-in-c">Plugins in C</a></li>
<li><a href="https://sourcey.com/building-a-simple-cpp-cross-platform-plugin-system/">Building a Simple C++ Cross-platform Plugin System</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx">GetProcAddress (for loading DLLs on Windows)</a></li>
<li><a href="https://linux.die.net/man/3/dlsym">dlsym (the Linux equivalent)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_loading">Wikipedia also has a pretty accurate article on the topic</a></li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./testing.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./fun/index.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./testing.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./fun/index.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
