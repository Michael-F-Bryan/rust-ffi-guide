<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Core Client Library - The (unofficial) Rust FFI Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Using unsafe for fun and profit!">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./overview.html"><strong>1.</strong> Overview</a></li><li><a href="./setting_up.html"><strong>2.</strong> Setting Up</a></li><li><a href="./client.html" class="active"><strong>3.</strong> Core Client Library</a></li><li><a href="./basic_request.html"><strong>4.</strong> Constructing a Basic Request</a></li><li><a href="./send_basic.html"><strong>5.</strong> Sending the Request</a></li><li><a href="./cbindgen.html"><strong>6.</strong> Generating a Header File</a></li><li><a href="./errors/index.html"><strong>7.</strong> Better Error Handling</a></li><li><ul class="section"><li><a href="./errors/return_types.html"><strong>7.1.</strong> Return Types</a></li><li><a href="./errors/logging.html"><strong>7.2.</strong> Logging</a></li><li><a href="./errors/exception_safety.html"><strong>7.3.</strong> Exception Safety</a></li></ul></li><li><a href="./async.html"><strong>8.</strong> Asynchronous Operations</a></li><li><a href="./complex_request.html"><strong>9.</strong> More Complex Requests</a></li><li><a href="./testing.html"><strong>10.</strong> Testing</a></li><li><a href="./dynamic_loading.html"><strong>11.</strong> Dynamic Loading &amp; Plugins</a></li><li class="spacer"></li><li><a href="./fun/index.html"><strong>12.</strong> Break All The Things!!1!</a></li><li><ul class="section"><li><a href="./fun/problems.html"><strong>12.1.</strong> Problems</a></li><li><a href="./fun/solutions.html"><strong>12.2.</strong> Solutions</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The (unofficial) Rust FFI Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./client.html#the-core-client-library" id="the-core-client-library"><h1>The Core Client Library</h1></a>
<p>Before we can do anything else we'll need to create the core client library that
the GUI calls into. To reduce the amount of state being maintained, each request
will create a new <a href="https://docs.rs/reqwest/0.8.0/reqwest/struct.Client.html"><code>reqwest::Client</code></a> and accept a <code>Request</code> object, returning
some generic <code>Response</code>.</p>
<p>This isn't overly specific to doing FFI, in fact we probably won't write any FFI
bindings or C++ in this chapter. That said, it's still a very important stage
because poor architecture decisions here can often make life hard for you down
the road. In general, making the interface as small and high level as possible
will vastly reduce the implementation complexity.</p>
<p>The first thing to do is set up error handling using <code>error-chain</code>. I have
<code>cargo-edit</code> installed (<code>cargo install cargo-edit</code>), so adding it to my
<code>Cargo.toml</code> is as simple as running</p>
<pre><code>$ cargo add error-chain
</code></pre>
<p>You'll then need to add the corresponding <code>extern crate</code> statement to <code>lib.rs</code>.
While you're at it, add also the <code>reqwest</code>, <code>cookie</code>, <code>chrono</code>, <code>fern</code>, <code>log</code>
and <code>libc</code> crates both to <code>Cargo.toml</code> and <code>lib.rs</code>, as we are going to use
them as well afterwards.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/lib.rs

extern crate chrono;
extern crate cookie;
#[macro_use]
extern crate error_chain;
extern crate fern;
extern crate libc;
#[macro_use]
extern crate log;
extern crate reqwest;
#}</code></pre></pre>
<p>Now create an <code>errors.rs</code> module.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/errors.rs

error_chain!{
    foreign_links {
        Reqwest(::reqwest::Error);
    }
}
#}</code></pre></pre>
<p>First lets create a <code>Request</code> object;</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/request.rs

use cookie::CookieJar;
use reqwest::{self, Method, Url};
use reqwest::header::{Cookie, Headers};


/// A HTTP request.
#[derive(Debug, Clone)]
pub struct Request {
    pub destination: Url,
    pub method: Method,
    pub headers: Headers,
    pub cookies: CookieJar,
    pub body: Option&lt;Vec&lt;u8&gt;&gt;,
}
#}</code></pre></pre>
<p>Add a constructor method as used by <code>request_create()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Request {
    pub fn new(destination: Url, method: Method) -&gt; Request {
        let headers = Headers::default();
        let cookies = CookieJar::default();
        let body = None;

        Request {
            destination,
            method,
            headers,
            cookies,
            body,
        }
    }
}
#}</code></pre></pre>
<p>We'll also need to be able to convert our <code>Request</code> into a <code>reqwest::Reqwest</code>
before we can send it so lets add a helper method for that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Request {
    pub(crate) fn to_reqwest(&amp;self) -&gt; reqwest::Request {
        let mut r = reqwest::Request::new(self.method.clone(), self.destination.clone());

        r.headers_mut().extend(self.headers.iter());

        let mut cookie_header = Cookie::new();

        for cookie in self.cookies.iter() {
            cookie_header.set(cookie.name().to_owned(), cookie.value().to_owned());
        }
        r.headers_mut().set(cookie_header);

        r
    }
}
#}</code></pre></pre>
<p>We also want to create our own vastly simplified <code>Response</code> so it can be
accessed by the C++ GUI, it gets a helper method too.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/response.rs

use std::io::Read;
use reqwest::{self, StatusCode};
use reqwest::header::Headers;

use errors::*;


#[derive(Debug, Clone)]
pub struct Response {
    pub headers: Headers,
    pub body: Vec&lt;u8&gt;,
    pub status: StatusCode,
}

impl Response {
    pub(crate) fn from_reqwest(original: reqwest::Response) -&gt; Result&lt;Response&gt; {
        let mut original = original.error_for_status()?;
        let headers = original.headers().clone();
        let status = original.status();

        let mut body = Vec::new();
        original
            .read_to_end(&amp;mut body)
            .chain_err(|| &quot;Unable to read the response body&quot;)?;

        Ok(Response {
            status,
            body,
            headers,
        })
    }
}
#}</code></pre></pre>
<blockquote>
<p><strong>Note:</strong> everything in a <code>Request</code> and <code>Response</code> has been marked as
public because it's designed to be a dumb container of everything necessary
to build a request.</p>
</blockquote>
<p>To help out with debugging the FFI bindings later on we'll add in logging via
the <code>log</code> and <code>fern</code> crates. In a GUI program it's often not feasible to add in
<code>println!()</code> statements and logging is a great substitute. Having a log file is
also quite useful if you want to look back over a session to see what requests
were sent and what the server responded with.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/utils.rs

use std::sync::{Once, ONCE_INIT};
use fern;
use log::LogLevelFilter;
use chrono::Local;

use errors::*;

/// Initialize the global logger and log to `rest_client.log`.
///
/// Note that this is an idempotent function, so you can call it as many
/// times as you want and logging will only be initialized the first time.
#[no_mangle]
pub extern &quot;C&quot; fn initialize_logging() {
    static INITIALIZE: Once = ONCE_INIT;
    INITIALIZE.call_once(|| {
        fern::Dispatch::new()
            .format(|out, message, record| {
                let loc = record.location();

                out.finish(format_args!(
                    &quot;{} {:7} ({}#{}): {}{}&quot;,
                    Local::now().format(&quot;[%Y-%m-%d][%H:%M:%S]&quot;),
                    record.level(),
                    loc.module_path(),
                    loc.line(),
                    message,
                    if cfg!(windows) { &quot;\r&quot; } else { &quot;&quot; }
                ))
            })
            .level(LogLevelFilter::Debug)
            .chain(fern::log_file(&quot;rest_client.log&quot;).unwrap())
            .apply()
            .unwrap();
    });
}
#}</code></pre></pre>
<p>Initializing logging will usually panic if you call it multiple times, therefore
we're using <code>std::sync::Once</code> so that <code>initialize_logging()</code> will only ever set
up <code>fern</code> once.</p>
<p>The logging initializing itself looks pretty gnarly, although that's mainly
because of the large <code>format_args!()</code> statement and having to make sure we add
in line endings appropriately.</p>
<p>We'll also add a <code>backtrace()</code> helper to the <code>utils</code> module. This just takes an
<code>Error</code> and iterates through it, logging a nice stack trace.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/utils.rs

/// Log an error and each successive thing which caused it.
pub fn backtrace(e: &amp;Error) {
    error!(&quot;Error: {}&quot;, e);

    for cause in e.iter().skip(1) {
        warn!(&quot;\tCaused By: {}&quot;, cause);
    }
}
#}</code></pre></pre>
<p>We'll also create a generic <code>send_request()</code> function which takes a <code>Request</code>
object and sends it, retrieving the resulting <code>Response</code>. Thanks to our two
helper functions the implementation is essentially trivial (modulo some logging
stuff).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/lib.rs

use reqwest::Client;
pub use request::Request;
pub use response::Response;
use errors::*;


/// Send a `Request`.
pub fn send_request(req: &amp;Request) -&gt; Result&lt;Response&gt; {
    info!(&quot;Sending a GET request to {}&quot;, req.destination);
    if log_enabled!(::log::LogLevel::Debug) {
        debug!(&quot;Sending {} Headers&quot;, req.headers.len());
        for header in req.headers.iter() {
            debug!(&quot;\t{}: {}&quot;, header.name(), header.value_string());
        }
        for cookie in req.cookies.iter() {
            debug!(&quot;\t{} = {}&quot;, cookie.name(), cookie.value());
        }

        trace!(&quot;{:#?}&quot;, req);
    }

    let client = Client::builder()
        .build()
        .chain_err(|| &quot;The native TLS backend couldn't be initialized&quot;)?;

    client
        .execute(req.to_reqwest())
        .chain_err(|| &quot;The request failed&quot;)
        .and_then(|r| Response::from_reqwest(r))
}
#}</code></pre></pre>
<p>You'll notice that <code>chain_err()</code> has been used whenever anything may fail. This
allows us to give the user some sort of stack trace of errors and what caused
them, providing a single high level error message (i.e. &quot;The native TLS backend
couldn't be initialized&quot;), while still retaining the low level context if they
want to drill down and find out <em>exactly</em> what went wrong.</p>
<p>This method of error handling ties in quite nicely with the <code>backtrace()</code> helper
defined earlier. As you'll see later on, they can prove invaluable for
debugging issues when passing things between languages.</p>
<p>Register the four new modules in <code>lib.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// client/src/lib.rs

pub mod errors;
pub mod utils;
mod request;
mod response;
#}</code></pre></pre>
<p>Now we've got something to work with, we can start writing some FFI bindings.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./setting_up.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./basic_request.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./setting_up.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./basic_request.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-78714693-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
